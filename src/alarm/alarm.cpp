#include "alarm.h"
#include <iostream>
#include <sqlite/execute.hpp>
#include <sqlite/query.hpp>

AlarmMgr::AlarmMgr() : AlarmMgr::AlarmMgr("alarm.db") {}
AlarmMgr::AlarmMgr(std::string alarmdb_name) : alarmdb(alarmdb_name)
{
    try
    {
        sqlite::execute(alarmdb, "CREATE TABLE alarms"
                "("
                " id INTEGER PRIMARY KEY,"
                " series_name TEXT,"
                " dow INT,"
                " hr INT,"
                " min INT,"
                " start_date DATE,"
                " stop_date DATE,"
                " last_run DATETIME"
                ");", true);
    }
    catch(std::exception const & e)
    {
        std::cerr << e.what() << std::endl;
    }
}
AlarmMgr::~AlarmMgr() {}

void AlarmMgr::check_alarms()
{
    // Get the time.
    time_t rawtime;
    time(&rawtime);
    struct tm* now = localtime (&rawtime);

    sqlite::query q(alarmdb, "SELECT * FROM alarms" // Find an alarm that
            " WHERE start_date<=strftime('%s', 'now')" // Has started
            " AND stop_date>=strftime('%s', 'now', 'start of day', '+1 day')" // Has not expired
            " AND last_run<=strftime('%s','now', '-1 minute');"); // and has not been run.
    boost::shared_ptr<sqlite::result> result = q.get_result();
    while(result->next_row())
    {
        if( (result->get_int((int)col_names::dow) == now->tm_wday || // If the alarm is for this day
             result->get_int((int)col_names::dow) == -1) && // Or every day
             result->get_int((int)col_names::hr)  == now->tm_hour  && // and for this hour
             result->get_int((int)col_names::min) == now->tm_min) // and for this minute
        {
            // Activate alarm.
            m_signal_alarm_activated.emit(result->get_string((int)col_names::series_name));

            // Update alarm last run time.
            sqlite::execute upd(alarmdb, "UPDATE alarms SET"
                    " 'last_run'=strftime('%s','now') WHERE id == ?;");
            upd.bind(1, result->get_int((int)col_names::id));
            upd();
        }
    }
}

void AlarmMgr::set_alarm(std::string alarmid, tm* alarm_time, tm* start_date, tm* stop_date) {
    // Convert start and stop times to unix timestamps.
    int32_t start_time = mktime(start_date);
    int32_t stop_time = mktime(stop_date);

    sqlite::execute ins(alarmdb, "INSERT INTO alarms VALUES(?, ?, ?, ?, ?, ?, ?, ?);");
    // Insert columns are 1-indexed. Querys are 0-indexed.
    ins.bind(1+(int)col_names::id); // Binds null to id. Autogenerated.
    ins.bind(1+(int)col_names::series_name, alarmid);
    ins.bind(1+(int)col_names::dow,         alarm_time->tm_wday);
    ins.bind(1+(int)col_names::hr,          alarm_time->tm_hour);
    ins.bind(1+(int)col_names::min,         alarm_time->tm_min);
    ins.bind(1+(int)col_names::start_date,  start_time);
    ins.bind(1+(int)col_names::stop_date,   stop_time);
    ins.bind(1+(int)col_names::last_run,    0);
    ins();
}

void AlarmMgr::deactivate_alarm(std::string alarmid, bool snooze)
{
    m_signal_alarm_deactivated.emit(alarmid);
    if(snooze)
    {
        time_t rawtime;
        time(&rawtime);

        struct tm start_date = *localtime(&rawtime);

        struct tm alarm_time = *localtime(&rawtime);
        alarm_time.tm_min = alarm_time.tm_min + 5;

        struct tm end_date = *localtime(&rawtime);
        end_date.tm_mday = end_date.tm_mday + 1;

        set_alarm(alarmid+"-snoozed", &alarm_time, &start_date, &end_date);
    }
}

void AlarmMgr::deactivate_alarm()
{
    m_signal_alarm_deactivated.emit("*");
}

AlarmMgr::type_signal_alarm AlarmMgr::signal_alarm_activated()
{
    return m_signal_alarm_activated;
}

AlarmMgr::type_signal_alarm AlarmMgr::signal_alarm_deactivated()
{
    return m_signal_alarm_deactivated;
}
